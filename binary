// -------------------------------------------------------  book allocation

function isCan(arr , pages , s){
    let student = 1
    let curr = 0
    
    for(const p of arr){
        if(p + curr > pages){
            student++
            curr = 0
        }
        curr+= p
    }
    return student <= s
}

function readBook(arr , S){
    let low = Math.max(...arr)
    let high = arr.reduce((result , curr)=> result + curr ,  0)
    let ans = high

    while(low <= high){
        const mid = Math.floor((low + high) / 2)
        if(isCan(arr , mid , S)){
          ans = mid
          high = mid - 1
        }
        else{
           low = mid + 1
        }
    }
    return ans
}

console.log(readBook([12, 34, 67, 90], 2))


// --------------------------------- find peak ------------------------------------------------------------------
function findPeak(arr){
    let low = 0
    let high = arr.length - 1

    while(low < high){
        const mid = Math.floor((low + high) / 2)
        if(arr[mid] < arr[mid + 1]){
            low = mid + 1
        }
        else{
            high = mid
        }
    }
    return high
}


console.log(findPeak([1, 3, 5, 7, 6, 4, 2]))

// mountain array search (first find the peak and after that do the binary search on two sides) - biotic array search
function findPeek(arr){
    let low = 0 , high = arr.length - 2
    while(low < high){
        const mid = Math.floor((low + high) / 2)
        if(arr[mid] < arr[mid + 1]){
            low = mid + 1
        }
        else{
            high = mid
        }
    }
    return low
}
function binarySearch(arr , target , start , end){
   let low = start , high = end
   while(low <= high){
      const mid = Math.floor((low + high) / 2)
      if(arr[mid] === target){
         return mid
      }
      else if(arr[mid] < target){
        low = mid + 1
      }
      else{
        high = mid - 1
      }
   }
   return -1
}
function binarySearchR(arr , target , start , end){
   let low = start , high = end
   while(low <= high){
      const mid = Math.floor((low + high) / 2)
      if(arr[mid] === target){
         return mid
      }
      else if(arr[mid] > target){
        low = mid + 1
      }
      else{
        high = mid - 1
      }
   }
   return -1
}
function searchInPeak(arr , target){
     const peak = findPeek(arr)

     const left = binarySearch(arr , target , 0 , peak);
     if(left !== -1) return left

     const right = binarySearchR(arr , target , peak + 1 , arr.length - 1)
     return right
}

console.log(searchInPeak([1,3,5,7,6,4,2] , 6))


// find peak in array find mid do if mid < mid + 1 move on to right while finally in low we got peak
function findLocalPeak(nums) {
  let low = 0;
  let high = nums.length - 1;

  while (low < high) {
    const mid = Math.floor((low + high) / 2);

    if (nums[mid] < nums[mid + 1]) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }

  return low;  // index of a local peak
}
console.log(findLocalPeak([2, 4, 3, 5, 1])); // 3


// find peak in 2D array (first need to find max mid row and after that compare that with left & right)
function peekIn2Darrays(arr){
    const rows = arr.length
    const colums = arr[0].length
    let low = 0 , high = colums - 1
    
    while(low <= high){
        const mid = Math.floor((low + high) / 2)

        // find max row
        let maxRow = 0
        for(let i = 0; i < rows; i++){
            if(arr[i][mid] > arr[maxRow][mid]){
                maxRow = i
            }
        }

        const leftVal = mid > 0 ? arr[maxRow][mid - 1] : -Infinity
        const rightVal = mid < colums - 1 ? arr[maxRow][mid + 1] : -Infinity

        if(arr[maxRow][mid] >= leftVal &&  arr[maxRow][mid] >= rightVal){
            return [maxRow , mid]
        }

        if(arr[maxRow][mid] < rightVal){
            
            low = mid + 1
        }
        else{
            high = mid - 1
        }
    }
}
const grid = [
  [1,  3,  5,  4],
  [2,  8, 10,  6],
  [3,  7,  9,  5],
  [1,  2,  4,  3]
];
console.log(peekIn2Darrays(grid))

// get a pivot and go for left and right (rotated array search)
function findAtRotateArray(arr , target){
    let low = 0 , high = arr.length - 1

    while(low <= high){
        const mid = Math.floor((low + high) / 2)

        if(arr[mid] === target) return mid


        if(nums[low] === num[mid] && num[mid] === num[high]){
            low++
            high--
        }

        if(arr[low] <= arr[mid]){
            if(arr[low] <= target && target < arr[mid]){
                high = mid - 1
            }
            else{
                low = mid + 1
            }
        }
        else{
            if(arr[mid] < target && target <= arr[high]){
               low = mid + 1
            }
            else{
                high = mid - 1
            }
        }
    }
    return -1
}

console.log(findAtRotateArray([4, 5, 6, 7, 0, 1, 2] , 1) )

function findMinimum(arr){
    let low = 0 , right = arr.length - 1
    while(low < right){
        const mid = Math.floor((low + right) / 2)
        if(arr[mid] > arr[right]){
            low = mid + 1
        }
        else{
            right = mid - 1
        }
    }
    return arr[low]
}
console.log(findMinimum([4,5,6,7,0,1,2]))
