// -------------------------------------------------------  book allocation

function isCan(arr , pages , s){
    let student = 1
    let curr = 0
    
    for(const p of arr){
        if(p + curr > pages){
            student++
            curr = 0
        }
        curr+= p
    }
    return student <= s
}

function readBook(arr , S){
    let low = Math.max(...arr)
    let high = arr.reduce((result , curr)=> result + curr ,  0)
    let ans = high

    while(low <= high){
        const mid = Math.floor((low + high) / 2)
        if(isCan(arr , mid , S)){
          ans = mid
          high = mid - 1
        }
        else{
           low = mid + 1
        }
    }
    return ans
}

console.log(readBook([12, 34, 67, 90], 2))


// --------------------------------- find peak ------------------------------------------------------------------
function findPeak(arr){
    let low = 0
    let high = arr.length - 1

    while(low < high){
        const mid = Math.floor((low + high) / 2)
        if(arr[mid] < arr[mid + 1]){
            low = mid + 1
        }
        else{
            high = mid
        }
    }
    return high
}


console.log(findPeak([1, 3, 5, 7, 6, 4, 2]))

// mountain array search (first find the peak and after that do the binary search on two sides) - biotic array search
function findPeek(arr){
    let low = 0 , high = arr.length - 2
    while(low < high){
        const mid = Math.floor((low + high) / 2)
        if(arr[mid] < arr[mid + 1]){
            low = mid + 1
        }
        else{
            high = mid
        }
    }
    return low
}
function binarySearch(arr , target , start , end){
   let low = start , high = end
   while(low <= high){
      const mid = Math.floor((low + high) / 2)
      if(arr[mid] === target){
         return mid
      }
      else if(arr[mid] < target){
        low = mid + 1
      }
      else{
        high = mid - 1
      }
   }
   return -1
}
function binarySearchR(arr , target , start , end){
   let low = start , high = end
   while(low <= high){
      const mid = Math.floor((low + high) / 2)
      if(arr[mid] === target){
         return mid
      }
      else if(arr[mid] > target){
        low = mid + 1
      }
      else{
        high = mid - 1
      }
   }
   return -1
}
function searchInPeak(arr , target){
     const peak = findPeek(arr)

     const left = binarySearch(arr , target , 0 , peak);
     if(left !== -1) return left

     const right = binarySearchR(arr , target , peak + 1 , arr.length - 1)
     return right
}

console.log(searchInPeak([1,3,5,7,6,4,2] , 6))


// find peak in array find mid do if mid < mid + 1 move on to right while finally in low we got peak
function findLocalPeak(nums) {
  let low = 0;
  let high = nums.length - 1;

  while (low < high) {
    const mid = Math.floor((low + high) / 2);

    if (nums[mid] < nums[mid + 1]) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }

  return low;  // index of a local peak
}
console.log(findLocalPeak([2, 4, 3, 5, 1])); // 3


// find peak in 2D array (first need to find max mid row and after that compare that with left & right)
function peekIn2Darrays(arr){
    const rows = arr.length
    const colums = arr[0].length
    let low = 0 , high = colums - 1
    
    while(low <= high){
        const mid = Math.floor((low + high) / 2)

        // find max row
        let maxRow = 0
        for(let i = 0; i < rows; i++){
            if(arr[i][mid] > arr[maxRow][mid]){
                maxRow = i
            }
        }

        const leftVal = mid > 0 ? arr[maxRow][mid - 1] : -Infinity
        const rightVal = mid < colums - 1 ? arr[maxRow][mid + 1] : -Infinity

        if(arr[maxRow][mid] >= leftVal &&  arr[maxRow][mid] >= rightVal){
            return [maxRow , mid]
        }

        if(arr[maxRow][mid] < rightVal){
            
            low = mid + 1
        }
        else{
            high = mid - 1
        }
    }
}
const grid = [
  [1,  3,  5,  4],
  [2,  8, 10,  6],
  [3,  7,  9,  5],
  [1,  2,  4,  3]
];
console.log(peekIn2Darrays(grid))

// get a pivot and go for left and right (rotated array search)
function findAtRotateArray(arr , target){
    let low = 0 , high = arr.length - 1

    while(low <= high){
        const mid = Math.floor((low + high) / 2)

        if(arr[mid] === target) return mid


        if(nums[low] === num[mid] && num[mid] === num[high]){
            low++
            high--
        }

        if(arr[low] <= arr[mid]){
            if(arr[low] <= target && target < arr[mid]){
                high = mid - 1
            }
            else{
                low = mid + 1
            }
        }
        else{
            if(arr[mid] < target && target <= arr[high]){
               low = mid + 1
            }
            else{
                high = mid - 1
            }
        }
    }
    return -1
}

console.log(findAtRotateArray([4, 5, 6, 7, 0, 1, 2] , 1) )

function findMinimum(arr){
    let low = 0 , right = arr.length - 1
    while(low < right){
        const mid = Math.floor((low + right) / 2)
        if(arr[mid] > arr[right]){
            low = mid + 1
        }
        else{
            right = mid - 1
        }
    }
    return arr[low]
}
console.log(findMinimum([4,5,6,7,0,1,2]))



function findMedianArray(a , b){
    if(a.length > b.length) return findMedianArray(b , a)
  const n1 = a.length , n2 = b.length
  let low = 0 , high = n1

  while(low <= high){
    const cut1 = Math.floor((low + high) / 2)
    const cut2 = Math.floor((n1 + n2 + 1) / 2) - cut1

    const left1 = cut1 === 0 ? -Infinity : a[cut1 - 1]
    const right1 = cut1 === n1 ? Infinity : a[cut1]

    const left2 = cut2 === 0 ? -Infinity : b[cut2 - 1]
    const right2 = cut2 === n2 ? Infinity : b[cut2]

    if(left1 <= right2 && left2 <= right1){
        if((n1 + n2) % 2 === 0){
            return (Math.max(left1 , left2) + Math.min(right1 , right2)) / 2
        }
        return Math.max(left1 , left2)
    }

    if(left2 > right1){
        low = cut1 + 1
    }
    else{
        high = cut1 - 1
    }
  }
}

console.log(findMedianArray([1, 3, 8], [2, 4, 6, 9]))


// find bad versio
function isBad(v , bad){
    return v >= bad
}

function firstBadversion(n){
  let low = 0 , high = n
  let ans = -1

  while(low <= high){
    const mid = Math.floor((low  + high) / 2)
    if(isBad(mid , 4)){
       ans = mid
       high = mid - 1
    }
    else{
        low = mid + 1
    }
  }
  return ans
}
console.log(firstBadversion(7))

function binarySearchInity(arr , target){
    let low = 0 , high = 1

    while(high < arr.length && arr[high] < target){
        low = high
        high = high * 2
    }

    high = Math.min(high , arr.length)

    while(low <= high){
        const mid = Math.floor((low + high) / 2)
        if(arr[mid] === target) return mid
        else if(arr[mid] < target) low = mid + 1
        else high = mid - 1
    }
    return -1
}
console.log(binarySearchInity([1, 3, 5, 7, 9, 12, 15, 18, 25, 30, 40] , 18))

// split array (binary search on answer - implicit search)

function splitArrayMinLargestSum(nums, k) {
  let low = Math.max(...nums);        // smallest possible max sum
  let high = nums.reduce((a, b) => a + b, 0); // largest possible

//   const canSplit = (limit) => {
//     let count = 1, sum = 0;

//     for (let num of nums) {
//       if (sum + num > limit) {
//         count++;
//         sum = num;
//         if (count > k) return false;
//       } else {
//         sum += num;
//       }
//     }
//     return true;
//   };

const canSplit = (limit) => {
    let count = 1, sum = 0;

    for (let num of nums) {
      if (sum + num > limit) {
        count++;
        sum = num;
        if(count > k) return false
      }
      else{
      sum += num;
      }
    }
    return count <= k;
  };

  while (low <= high) {
    const mid = Math.floor((low + high) / 2);

    if (canSplit(mid)) {
      high = mid - 1;   // try smaller maximum
    } else {
      low = mid + 1;    // need larger limit
    }
  }
  return low;
}

// sample input
console.log(splitArrayMinLargestSum([7, 2, 5, 10, 8], 2)); 
// → 18


function searchMatrix2DArray(arr , target){
    const rows = arr.length
    const cols = arr[0].length

    let low = 0 , high = rows * cols - 1

    while(low <= high){
        const mid = Math.floor((low + high) / 2)

        const r = Math.floor(mid / cols)
        const c = Math.floor(mid % cols)

        if(arr[r][c] === target) return [r ,c]
        else if(arr[r][c] < target){
            low = mid + 1
        }
        else{
            high = mid - 1
        }
    }
    return -1
}
console.log(searchMatrix2DArray([
  [1, 3, 5],
  [7, 9, 11],
  [13, 15, 17]
] , 9))


// normal binary search instead of check mid need to check mid - 1 , mid + 1
function NearlySortedSearch(arr , target){
    let low = 0 , high = arr.length

    while(low <= high){
        const mid = Math.floor((low + high) / 2)
        
        if(arr[mid] === target) return mid
        if(mid - 1 >= low && arr[mid - 1] ===  target)  return mid - 1
        if(mid + 1 <= high && arr[mid + 1] ===  target)  return mid + 1

        if(arr[mid] > target){
            high = mid - 2
        }
        else{
            low = mid + 2
        }
    }
}
console.log(NearlySortedSearch([10, 3, 40, 20, 50, 80, 70], 40)); // → 2


// find place to fit the cow (first find the mid and low and high distance after that check the last cow - current cow >= dis)
function isPlace(stalls , cows , dic){
   let count = 1
   let last = stalls[0]

   for(let i=0; i < stalls.length; i++){
     if(stalls[i] - last >= dic){
        count++
        last = stalls[i]
     }
     if(count === cows) return true
    }
    return false
}

function cowPlacement(stalls , cows){
   let low = 1 , high = stalls[stalls.length - 1] - stalls[0] , ans = 0

   while(low <= high){
     const mid = Math.floor((low + high) / 2)
     if(isPlace(stalls , cows , mid)){
         ans = mid
         low = mid + 1
     }
     else{
        high = mid - 1
     }
   }
   return ans
}

console.log(cowPlacement([1, 2, 4, 8, 9], 3))
